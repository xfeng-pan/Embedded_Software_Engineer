# 10-互斥量的使用

# 互斥量

我们来看一个生活中的例子:现在大多银行ATM机都有一个特制的铁门。

需要使用ATM的用户都需要在门前排队，进入铁门使用ATM机的用户进入后会在里面将铁门锁住，以保障自身安全，这个时候，在门外排队的用户无法使用ATM机:当之前锁住ATM铁门的用户办理完业务，打开门以后，其他在外排队的用户才可以进入铁门使用ATM，这位进入铁门的用户也会和前一个用户一样，将门锁住，保障自身的安全。

例子中ATM机就相当于系统中的共享资源，需要使用ATM的用户相当于系统中的线程，而铁门，就起到了互斥量的作用；

# 互斥量工作机制

互斥量(石斥锁]是用于线程间互斥访问的IPC对象，它是一种特殊的二值性信号量。当某个线程访问系统中的共享资源时，通过引入互斥量机制，可以保证其他线程无法取得对此共享资源的访问权。

![Img](/00-嵌入式软件工程师/05-RT_Thread/02-RT_Thread官方入门教程/10-互斥量的使用/FILES/10-互斥量的使用.md/img-20230421100534.png)


互斥量只有两种状态:LOCKED和UNLOCKED，分别代表加锁和开锁的两种情况当有线程持有它时，互斥量处于闭锁状态，由这个线程获得它的所有权。相反，当这个线程释放它时，将对互斥量进行开锁，失去对它的所有权。当一个线程持有互斥量时，其他线程将不能够对它进行开锁或持有它。持有该互斥量的线程也能够再次获得这个“锁“(递归持有)而不被挂起


# 互斥量控制块

```C
struct rt_mutex
{
    struct rt_ipc_object parent;                        /**< inherit from ipc_object */

    rt_uint16_t          value;                         /**< value of mutex */

    rt_uint8_t           original_priority;             /**< priority of last thread hold the mutex */
    rt_uint8_t           hold;                          /**< numbers of thread hold the mutex */

    struct rt_thread    *owner;                         /**< current owner of mutex */
};
typedef struct rt_mutex *rt_mutex_t;
```

## 定义动态与静态互斥量

```C
//动态
rt_mutex_t dynamic_mutex;
//静态
struct rt_mutex static_mutex;
```

# 互斥量的操作

![Img](/00-嵌入式软件工程师/05-RT_Thread/02-RT_Thread官方入门教程/10-互斥量的使用/FILES/10-互斥量的使用.md/img-20230421105207.png)


互斥量只能在线程中操作，而信号量可以在中断中操作；


# 互斥量的实例

详见例程代码；


# 互斥量VS信号量

1、信号量可以由任何线程(以及中断)释放，它用于同步的时候就像交通灯，线程只有在获得许可的时候才可以运行，强调的是运行步骤;

互斥量只能由持有它的线程释放，即只有“锁上”它的那个线程才有“钥匙”打开它。它用于互斥的时候就像一把钥匙，只有获得钥匙的线程才可以运行，强调的是许可和权限。

2、使用信号量可能导致线程优先级反转，而互斥量可通过优先级继承的方法解决优先级反转问题


















