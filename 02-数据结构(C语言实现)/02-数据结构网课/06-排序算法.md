# 06-排序算法

# 排序的概念及其运用

## 排序的概念

**排序**：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。

**稳定性**：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。

**内部排序**：数据元素全部放在内存中的排序。

**外部排序**：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。


## 排序运用

1. 电商商品排序（按价格，按销量，按评价）
2. 榜单排名

## 常见排序

1. 插入排序：直接插入排序 希尔排序
2. 选择排序；选择排序 堆排序
3. 交换排序：冒泡排序 快速排序
4. 归并排序；归并排序
4. 其他排序；基数排序，计数排序

最常用的排序：快速排序


![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/06-排序算法.md/img-20230408100352.png)


# 插入排序

## 基本思想

插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。

## 直接插入排序

![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/06-排序算法.md/img-20230408101505.png)

向一个有序队列中插入一个新的值，从后往前或者从前往后比较，直到满足升序或者降序要求

```C
//直接插入排序
void InsertSort(int* a, int n)
{
	// a 是数组指针，指向数组头
	// n 是数组内的元素数量， 最大下标为 n - 1；
	// [0, end]是有序的， 将end + 1位置的值插入进去，让[0, end + 1]有序
	for (int i = 0; i < n - 1; i++)
	{
		int end = i;
		int tmp = a[end + 1];
		while (end >= 0)
		{
			if(tmp > a[end]) // 降序排列 
			// if (tmp < a[end]) //升序排列
			{
				a[end + 1] = a[end];
				end--;
			}
			else break;
		}
		a[end + 1] = tmp;
	}
}
```
1. 元素集合越接近有序，直接插入排序算法的时间效率越高
2. 时间复杂度：O(N^2)
3. 空间复杂度：O(1)，它是一种稳定的排序算法
4. 稳定性：稳定

最坏情况：对逆序的数据进行排列，需要排（0+1+2+3+...+(n-1))= (n-1)n/2次，即O(N^2)
最好情况：对顺序的数据进行排列，只需要O(N);

## 希尔排序（缩小增量排序）

是在直接排序的方法上进行的优化


先选定一个整数，把待排序文件中所有记录分成个组，所有距离为的记录分在同一组内，并对每一组内的记录进行排序。然后，取，重复上述分组和排序的工作。当到达=1时，所有记录在统一组内排好序。

先进行预排序，让数组接近有序，然后在进行直接排序

![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/06-排序算法.md/img-20230408110135.png)

1. 希尔排序是对直接插入排序的优化。
2. 当gap > 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。
3. 希尔排序的时间复杂度不好计算，需要进行推导，推导出来平均时间复杂度： O(N^1.3 — N^2）
4. 稳定性：不稳定

对间隔为gap的预排序，gap由大变小，gap越大，越容易将较大的数挪到前面，但是越不接近与有序

gap == 1 的时候就是直接插入排序；

**gap的值越大，对于大数据而言，速度更快；**

```C
void ShellSort(int* a, int n, int gap)
{
	while (gap > 0)
	{
		for (int i = 0; i < n - gap; ++i)
		{
			int end = i;
			int tmp = a[end + gap];
			while (end >= 0)
			{
				if (tmp < a[end])//升序 //if (tmp < a[end])//降序
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else break;
			}
			a[end + gap] = tmp;
		}
		gap /= 2;
		//gap = gap/3 + 1;//保证gap最后的值是1
	}
}
```
希尔排序的时间复杂度：
当gap很大的时候，接近于N，当gap很小的时候，已经接近于有序了，也是N，而循环的次数是logN，所以整体的时间复杂度是O(N*logN);


# 选择排序

## 堆排序

堆排序中的堆的逻辑结构是一个完全二叉树

堆的物理结构是一个数组

可以通过下标来确定父子节点的关系

```
leftchild = parent * 2 + 1;
rightchild = parent * 2 + 2;

parent = (child - 1) / 2;(child 没有左右之分，依靠整数除法消去)
```

堆的两个特性：
1. 结构性：用数组表示的完全二叉树
2. 有序性：任意节点的关键字是其子树所有节点的最大值（或者最小值）
 + 最大堆（maxHeap)：也叫做“大顶堆”：最大值
 + 最小堆（minHeap): 也叫做“小顶堆”；最小值

### 堆排序的向下调整算法
建小堆

前提：左右子树都是小堆

从根节点开始，选出左右子节点中较小的那个和父节点比较，如果比父节点小就交换，然后继续往下进行交换，然后继续调，直到叶节点位置

当左右子树不是小堆的时候，就不能使用向下调整算法

要建小堆，就需要从最后一颗树开始调整（叶子不需要调，因此，需要从最后一个非叶子的子树开始调整）

最后一个非叶子的子树的根节点为： (n-1-1)/2

建堆的时间复杂度是O(N);

排升序：要建大堆
原因：如果是建小堆，则最小的数已经在堆顶了，被选出来了，再选小的数还需要建堆，但是剩下的是树的结构都乱了，还需要重新建堆才能选出下一个数，而建堆的时间复杂度是O(N)，这样也能完成任务，但是堆排序就没有优势了，
建完大堆之后，交换第一个数和最后一个数，此时最大的数就到最后去了，剩下的左子树和右子树还是大堆
然后前n-1个数继续向下调整，选出次大的数，与倒数第二个数进行交换...
最终完成排序

交换的时间复杂度：O(logN)

总体的时间复杂度：O(N*logN);

排降序；要建小堆

### 堆排序的代码
```C
void Swap(int* p1, int* p2)
{
	int tmp = *p1;
	*p1= *p2;
	*p2 = tmp;
}

//向下调整算法
void AdjustDown(int* a, int n, int root)
{
	int parent = root;
	int child = root * 2 + 1;//默认指向左子代

	while (child < n)
	{
		if (child + 1 < n && a[child] > a[child + 1])//检测是否有右孩子，并比较大小
		{
			child += 1;
		}
		if (a[parent] > a[child]) //建小堆 //建大堆：if (a[parent] < a[child]),上一个if中的比较也需要改变方向
		{
			Swap(&a[parent], &a[child]);
			parent = child;
			child = child * 2 + 1;
		}
		else break;
	}
}
// 堆排序
void HeapSort(int* a, int n)
{
	//把数组建成小堆
	for (int i = (n - 1 - 1) / 2; i >= 0; --i)
	{
		AdjustDown(a, n, i);
	}
	//排升序：要建大堆
	//排降序：要建小堆
	int end = n -1;
	while(end > 0)
	{
		Swap(&a[0], &a[end]);
		AdjustDown(a, end, 0);
		--end;
	}
}
```






