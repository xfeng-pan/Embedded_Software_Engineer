# 05-树形结构之二叉树

# 树的概念及结构

## 树的概念
树是一种非线性的数据结构，它是由n（n>=0）个有限结点组成一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

+ 有一个特殊的结点，称为根结点，根节点没有前驱结点
+ 除根节点外，其余结点被分成M(M>0)个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti(1<= i <= m)又是一棵结构与树类似的子树。每棵子树的根结点有且只有一个前驱，可以有0个或多个后继
+ 因此，树是递归定义的

![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/05-树形结构之二叉树.md/img-20230406143951.png)

![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/05-树形结构之二叉树.md/img-20230406144010.png)


+ 节点的度：一个节点含有的子树的个数称为该节点的度； 如上图：A的为6
+ 节点或终端节点：度为0的节点称为叶节点； 如上图：B、C、H、I...等节点为叶节点
非终端节点或分支节点：度不为0的节点； 如上图：D、E、F、G...等节点为分支节点
+ 双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 如上图：A是B的父节点
+ 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 如上图：B是A的孩子节
点
+ 兄弟节点：具有相同父节点的节点互称为兄弟节点； 如上图：B、C是兄弟节点（只有亲兄弟才能成为兄弟节点）
+ 树的度：一棵树中，最大的节点的度称为树的度； 如上图：树的度为6
+ 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
+ 树的高度或深度：树中节点的最大层次； 如上图：树的高度为4
+ 节点的祖先：从根到该节点所经分支上的所有节点；如上图：A是所有节点的祖先
+ 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是A的子孙
+ 森林：由m（m>0）棵互不相交的多颗树的集合称为森林；（数据结构中的学习并查集本质就是一个森林） (日常中很少碰到树)


## 树的表示
双亲表示法，孩子表示法、孩子兄弟表示法

其中最简单的是孩子兄弟表示法：

![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/05-树形结构之二叉树.md/img-20230406144941.png)

```C
typedef int DataType;
struct Node
{
  struct Node* _firstChild1;   // 第一个孩子结点
  struct Node* _pNextBrother;  // 指向其下一个兄弟结点
  DataType _data;        // 结点中的数据域
};
```

双亲表示法：
![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/05-树形结构之二叉树.md/img-20230406145233.png)


树的典型应用：文件系统

![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/05-树形结构之二叉树.md/img-20230406145449.png)


# 二叉树概念及结构

## 二叉树概念

一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵别称为左子
树和右子树的二叉树组成。

特点：
1. 每个结点最多有两棵子树，即二叉树不存在度大于2的结点。
2. 二叉树的子树有左右之分，其子树的次序不能颠倒。


# 二叉树的遍历

## 分治算法的概念

分而治之，大问题分为类似的子问题，子问题再分为子问题，直到子问题不可再分割

## 遍历顺序

前序：根，左子树，右子树
中序：左子树，根，右子树
后序：左子树，右子树，根
![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/05-树形结构之二叉树.md/img-20230406154302.png)

前序：A B D E C 
(A B D NULL NULL E NULL NULL C NULL NULL)
中序；D B E A C
(NULL D NULL B NULL E NULL A NULL C NULL)
后序：D  E B C A
(NULL NULL D NULL NULL E B NULL NULL C A)

### 前序遍历

```C
void PreOrder(BTNode* root)
{
	if (root == NULL)
	{
		printf("NULL ");
		return;
	}
	printf("%c ", root->data);
	PreOrder(root->left);
	PreOrder(root->right);
	//前序遍历
}
```


画函数递归展开图，有助于深入理解代码















