# 03-线性表之链表

顺序表中存在的问题：
1. 中间/头部的删除，时间复杂度：O(N);
2. 增容需要申请新的空间，销毁旧空间，消耗大
3. 增容会造成空间浪费

解决方法：
1. 空间上，按需给空间
2. 不要求物理空间上的连续，头部和中间的插入就不需要挪动数据了。
3. 


# 链表的概念及结构

## 链表的概念

链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表
中的指针链接次序实现的 。

逻辑结构：
![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/03-线性表之链表.md/img-20230401183346.png)

物理结构：
![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/03-线性表之链表.md/img-20230401190214.png)





## 链表的结构

链表通过组合一共会有八种结构：
1. 带头 不带头
2. 单向 双向
3. 循环 非循环

一般常用的两种是：
1. 无头单向非循环链表
2. 带头双向循环链表

带头的有点：带哨兵位的头节点，第一个节点不存储有效数据。这样可以在尾插以及头插的时候，不单独区分链表是否为空。

### 无头单向非循环链表

结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。

#### 单链表的缺陷
复杂度高：PopBack的复杂度是O(N),Insert的复杂度也是O(N),Erase的时间复杂度也是O(N)，本质是每个功能都需要去找上一个元素。
 
解决方案：双向链表，尾插的判断更简单，头删也很简单。
本质；不需要改变传过来的指针，也就意味着不需要传二级指针


### 带头双向循环链表

结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。另外这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势，实现反而简单了，后面我们代码实现了就知道了。

插入，修改的最优的链表结构

查找适合用：
1. 平衡搜索树（AVL树和红黑树）
2. 哈希表
3. B树，B+树系列
4. 其它：跳表，布隆，位图


# 链表的代码实现

## 无头单向非循环链表

```C
typedef int SLTDataType;//链表的数据类型

typedef struct SListNode
{
	SLTDataType data;
	struct SListNode* next;//这是一个指针，指向的是一个结构体
}SLTNode;

//不会改变链表的头指针，传一级指针
void SListPrint(SLTNode* phead);
//会改变链表的头指针，传二级指针
void SListPushBack(SLTNode** pphead, SLTDataType x);
void SListPushFront(SLTNode** pphead, SLTDataType x);
void SListPopBack(SLTNode** pphead);
void SListPopFront(SLTNode** pphead);

SLTNode* SListFind(SLTNode* phead, SLTDataType x);

//在pos的前面插入x
void SListInsert(SLTNode** pphead, SLTNode* pos, SLTDataType x);
//删除pos位置的值
void SListErase(SLTNode** pphead, SLTNode* pos);
```

## 带头双向循环链表

```C

```



# 入门推荐书籍
> 数据结构 - 严蔚敏
> 数据结构（用面向对象方法与C++语言描述） 第2版 - 殷人昆
> 大话数据结构
> 剑指offer



















