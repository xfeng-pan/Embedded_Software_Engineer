# 04-线性表之栈和队列

# 栈的表示和实现

## 栈的概念及结构

栈： 一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。栈中的数据元素遵守后进先出LIFO的原则。

压栈： 栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。

出栈： 栈的删除操作叫做出栈。出数据也在栈顶。

![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/04-线性表之栈和队列.md/img-20230404223033.png)

## 栈的实现

栈的实现一般可以使用数组或者链表实现，相对而言数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小。

![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/04-线性表之栈和队列.md/img-20230405111742.png)

数组来实现栈的唯一缺点就是空间不足的时候需要增容。

用链表来实现栈需要的是头插和头删：用单链表就可以实现O(1)的插入和删除，双向循环链表也可以很简单的实现，但是一般不会用双向循环链表
![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/04-线性表之栈和队列.md/img-20230405112028.png)

实际上一般直接使用数组来实现栈
数组更容易被加载到cpu的缓存中

> 深入理解计算机系统

## 栈的代码实现
```C
typedef int STDatatype;

// 用数组来实现的方法：用top来标记栈顶
typedef struct Stack
{
	STDatatype* a;//这是动态数据表
	//STDatatype a[MAX];//这是静态数据表

	int top;
	int capacity;
}ST;


//初始化
void StackInit(ST* ps);

//销毁
void StackDestory(ST* ps);

//压栈
void StackPush(ST* ps, STDatatype x);

//出栈
void StackPop(ST* ps );

//读取栈顶数据
STDatatype StackTop(ST* ps);

//获取栈内数据个数
int StackSize(ST* ps);

//判断栈是否为空，1为空，0为非空
bool IsStackEmpty(ST* ps);
```



# 队列

## 队列的概念与结构

队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出FIFO(First In First Out) 入队列：进行插入操作的一端称为队尾 出队列：进行删除操作的一端称为队头。

队尾进，队头出

![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/04-线性表之栈和队列.md/img-20230405151806.png)

## 队列的实现
队列也可以数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构，出队列在数组头上出数据，效率会比较低。

用数组的话出数据的时间复杂度是O(N);

用单链表只需要头删和尾删就行，

![Img](/00-嵌入式软件工程师/02-数据结构%28C语言实现%29/02-数据结构网课/FILES/04-线性表之栈和队列.md/img-20230405152313.png)






# 概念选择题

1. 循环队列的存储空间为 Q(1:100) ，初始状态为 front=rear=100 。经过一系列正常的入队与退队操作后，front=rear=99 ，则循环队列中的元素个数为（ ）
A 100
B 2
C 99
D 0


2. 下列与队列应用的是（）
A 函数的递归调用
B 数组元素的引用
C 多重循环的执行
D 先到先服务的作业调度

3. 一个栈的初始状态为空。现将元素1、2、3、4、5、A、B、C、D、E依次入栈，然后再依次出栈，则
元素出栈的顺序是（  ）。
A 12345ABCDE
B EDCBA54321
C ABCDE12345
D 54321EDCBA

```
B
```

4. 若进栈序列为 1,2,3,4 ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（）
A 1,4,3,2
B 2,3,4,1
C 3,1,4,2
D 3,4,2,1
```
C
```















